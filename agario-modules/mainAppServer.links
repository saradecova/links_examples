open Util.Lists
open Render
open Logic
open MainAppClient
open ServerLogic

# keeps truck of all players, their states and channel on which the server
# communicates with them
fun players_manager(players, pids, new_id) {
  receive {
    case Update(player_id, player, pid) ->
      players_manager(dictUpdate(player_id, player, players), pids, new_id)
    case Add(player_id, player:PlayerState, ping_channel) ->
      var players = dictUpdate(player_id, player, players);
      var pids = dictUpdate(player_id, ping_channel, pids);
      players_manager(players, pids, new_id)
    case GeneratePlayerId(pid) ->
      print("In generate");
      pid ! new_id;
      players_manager(players, pids, new_id+1)
    case GetAllPids(pid) ->
      pid ! (players, pids);
      players_manager(players, pids, new_id)
  }
}

fun clientSendHandler(channel:ServerToClientPing) {
  receive {
    case DeliverNewState(players) -> clientSendHandler(send(players, channel))
  }
}

# repeatedly sends up-to-date players' state to all users
fun server_sender_ping(manager, prev_time) {
  fun broadcastState(players, pids) {
    switch(pids) {
      case [] -> ()
      case pid::pids -> pid ! DeliverNewState(players);
                        broadcastState(tl(players), pids)
    }
  }

  var curr_time = getTime(event);
  if (curr_time - prev_time > 30) {
    var (players, pids) =
      spawnWait { manager ! GetAllPids(self()); receive { case n -> n }};
    broadcastState(players, pids);
    server_sender_ping(manager, curr_time)
  } else {
    server_sender_ping(manager, prev_time)
  }
}

fun server_rec_ping(recChannel:UpdatePlayerChannel) {
  var (player_id, recChannel) = receive(recChannel);
  var (player:PlayerState, recChannel) = receive(recChannel);
  # update overall game state_node
 server_rec_ping(recChannel)
}

fun setup(s:InitiateGame, manager) {
  debug("starting setup");
  fun clientHandler(serverToClientRecvEnd, initGameChannel) {
    var _ = send(serverToClientRecvEnd, initGameChannel);
    debug("sent channel");
    ()
  }
  # send new player id.
  var player_id = spawnWait { manager ! GeneratePlayerId(self());
                              receive { case n -> n }};
  debug("got player id: "^^intToString(player_id));
  var s = send(player_id, s);

  #  Get client's initial state. (is same for every client so should be
  #  generated at the server. TODO: rewrite initial_game_state funtion so it
  #  does not use pure client-side functions and can bu run on server).
  var (player_state:PlayerState, s) = receive(s);
  debug("received player's state");

  # Generate a channel for sending regualar messages from server to client.
  var serverToClientSendEnd:ServerToClientPing = linFork(
    linfun (serverToClientRecvEnd:(~ServerToClientPing)) {
      clientHandler(serverToClientRecvEnd, s)
    });

  # Fork off client send handler
  var clientSendHandlerPid =
    spawn { clientSendHandler(serverToClientSendEnd) };

  # add new player to the manager
  manager ! Add(player_id, player_state, clientSendHandlerPid);
  ()
}

fun client_acceptor(ap, manager) {
  var s = accept(ap);
  var _ = spawn { setup(s, manager) };
  client_acceptor(ap, manager)
}

fun main() {
  var clientAP = new();

  var gameManager = spawn { players_manager([], [], 1) };
  var _ = spawn { client_acceptor(clientAP, gameManager) };
  addRoute("/", fun (_, _) { MainAppClient.mainPage(clientAP) } );
  addStaticRoute("/css", "css", [("css", "text/css")]);
  serveWebsockets();
  servePages()
}

main()
