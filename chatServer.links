open ChatSessions
open ChatClient

## clientHandler loop: Reads incoming requests from the client, dispatches
## each command to the serverLoop which will broadcast to other session clients.
# Alas, we can't make this an inner function at the moment since we need a type
# annotation, and type annotations are broken for inner functions at the moment
fun clientHandlerLoop(room, nick, clientToServerChan, loopPid) {

  offer(clientToServerChan) {
    case ChatMessage(clientToServerChan) ->
      var (msg, clientToServerChan) = receive(clientToServerChan);
      loopPid ! BroadcastMessage(room, nick, msg);
      clientHandlerLoop(room, nick, clientToServerChan, loopPid)
    case ChangeTopic(clientToServerChan) ->
      var (newTopic, clientToServerChan) = receive(clientToServerChan);
      loopPid ! BroadcastChangeTopic(room, newTopic);
      clientHandlerLoop(room, nick, clientToServerChan, loopPid)
  }
}


# Process that is spawned to handle messages from the chat client.
fun clientHandler(room, nick, chatServerRecvEnd, serverToClientRecvEnd, loopPid) {

  # Get the current topic and nicks
  loopPid ! GetServerState(room, self());
  var (room, topic, nicks) = receive { case st -> st };

  # if this is the first user, make him moderator
  var moderatorChannelSendEnd =
    if (nicks == [])
      fork( fun (moderatorChannelRecEnd) {
        moderatorHandler(room, moderatorChannelRecEnd, loopPid) })
    else
      fork ( fun (mockModeratorChannelRecEnd) {
        mockModeratorHandler(mockModeratorChannelRecEnd) });

  # Send topic, nicks, and outgoing channel
  var chatServerRecvEnd =
    send((room, topic, nicks, serverToClientRecvEnd, moderatorChannelSendEnd),
    chatServerRecvEnd);

  clientHandlerLoop(room, nick, chatServerRecvEnd, loopPid)
}

fun clientSendHandler(s) {
  receive {
    case DeliverMessage(nick, msg) ->
      var s = select IncomingChatMessage s;
      var s = send((nick, msg), s);
      clientSendHandler(s)
    case DeliverNewUser(nick) ->
      var s = select NewUser s;
      var s = send(nick, s);
      clientSendHandler(s)
    case DeliverNewTopic(topic) ->
      var s = select NewTopic s;
      var s = send(topic, s);
      clientSendHandler(s)
    case DeliverUserLeft(nick) ->
      var s = select UserLeft s;
      var s = send(nick, s);
      clientSendHandler(s)
  }
}

fun mockModeratorHandler(channel) {
  offer(channel) {
    case RemoveUser(channel) ->
      var (nick, channel) = receive(channel);
      #loopPid ! RemoveUser(room, nick);
      mockModeratorHandler(channel)
    case MuteUser(channel) ->
      var (nick, channel) = receive(channel);
      # loopPid ! MuteUser(room, nick);
      mockModeratorHandler(channel)
  }
}

fun moderatorHandler(room, channel, loopPid) {
  offer(channel) {
    case RemoveUser(channel) ->
      var (nick, channel) = receive(channel);
      #loopPid ! RemoveUser(room, nick);
      moderatorHandler(room, channel, loopPid)
    case MuteUser(channel) ->
      var (nick, channel) = receive(channel);
      # loopPid ! MuteUser(room, nick);
      moderatorHandler(room, channel, loopPid)
  }
}

# Broadcasts a given message to the mailboxes of a list of PIDs
fun broadcastMessage(msg, pids) {
  switch(pids) {
    case [] -> ()
    case pid :: pids -> pid ! msg; broadcastMessage(msg, pids)
  }
}

# finds pids (clinets) in a particular room
fun getItemsByRoom(theRoom, rooms, l) {
  switch(rooms) {
    case [] -> []
    case x::xs -> if (x == theRoom) hd(l)
                 else getItemsByRoom(theRoom, xs, tl(l))
  }
}

fun getTopicByRoom(theRoom, rooms, topics) {
  switch(rooms) {
    case [] -> Topic("")
    case x::xs -> if (x == theRoom) hd(topics)
                 else getTopicByRoom(theRoom, xs, tl(topics))
  }
}

fun addModeratorByRoom(room, rooms, nick, moderators) {
  switch(rooms) {
    case [] -> []
    case x::xs -> if (x == room && hd(moderators) == []) [nick]::tl(moderators)
                  else addModeratorByRoom(room, xs, nick, tl(moderators))
  }
}

fun addNickByRoom(room, rooms, nick, nicks) {
  switch(rooms) {
    case [] -> []
    case x::xs -> if (x == room) (nick::hd(nicks))::tl(nicks)
                  else addNickByRoom(room, xs, nick, tl(nicks))
  }
}

fun addPidByRoom(room, rooms, pid, pids) {
  switch(rooms) {
      case [] -> []
      case x::xs -> if (x == room) (pid::hd(pids))::tl(pids)
                    else addPidByRoom(room, xs, pid, tl(pids))
  }
}

fun changeTopicByRoom(room, rooms, newTopic, topics) {
  switch(rooms) {
    case [] -> []
    case x::xs -> if (x == room) newTopic::tl(topics)
                  else changeTopicByRoom(room, xs, newTopic, tl(topics))
  }
}

# Main server loop, containing server state. Awaits (non-session) control
# messages to update the state, or broadcast instructions to send things
# along session channels.
fun serverLoop(rooms, moderators, topics, nicks, pids) server {
  receive {
    case BroadcastMessage(room, nick, msg) ->
      broadcastMessage(DeliverMessage(nick, msg),
                       getItemsByRoom(room, rooms, pids));
      serverLoop(rooms, moderators, topics, nicks, pids)
    case BroadcastChangeTopic(room, newTopic) ->
      broadcastMessage(DeliverNewTopic(newTopic),
                       getItemsByRoom(room, rooms, pids));
      serverLoop(rooms, moderators,
                 changeTopicByRoom(room, rooms, newTopic, topics),
                 nicks, pids)
    case NewClient(room, nick, pid) ->
      broadcastMessage(DeliverNewUser(nick),
                       getItemsByRoom(room, rooms, pids));
      serverLoop(rooms,
                 addModeratorByRoom(room, rooms, nick, moderators),
                 topics,
                 addNickByRoom(room, rooms, nick, nicks),
                 addPidByRoom(room, rooms, pid, pids))
    case GetServerState(room, pid) ->
      pid ! (room,
             getTopicByRoom(room, rooms, topics),
             getItemsByRoom(room, rooms, nicks));
      serverLoop(rooms, moderators, topics, nicks, pids)
    case NewRoom(room) ->
      serverLoop(room::rooms, []::moderators, Topic("hello")::topics,
                 []::nicks, []::pids)
    case GetRooms(pid) ->
      pid ! (rooms);
      serverLoop(rooms, moderators, topics, nicks, pids)
  }
}

fun handleNickname(room, s, loopPid) {
  # Get the name and incoming message channel of the new client
  var (name, s) = receive(s);

  # Fork off the client handler,
  var serverToClientSendEnd = linFork(
    linfun (serverToClientRecvEnd) {
     clientHandler(room, name, s, serverToClientRecvEnd, loopPid)
  });

  # Fork off client send handler
  var clientSendHandlerPid = spawn { clientSendHandler(serverToClientSendEnd) };

  # Register with the main loop, and recurse
  loopPid ! NewClient(room, name, clientSendHandlerPid);
}

fun handleRoom(roomsSenderEnd, loopPid) server {
  fun member(elem , l) {
    switch(l) {
      case [] -> false
      case (x::xs) -> x == elem || member(elem, xs)
    }
  }

  # get all available rooms
  var rooms = spawnWait { loopPid ! GetRooms(self()) ; receive { case n -> n }};
  # send the rooms to the client.
  var s = send(rooms, roomsSenderEnd);
  # get the room selection from the client
  var (r, s) = receive(s);
  if (not(member(r, rooms))) loopPid ! NewRoom(r) else ();
  handleNickname(r, s, loopPid)
}

fun clientAcceptor(ap, loopPid) server {
  # Accept a new client
  var s = accept(ap);
  var _ = spawn { handleRoom(s, loopPid) };
  clientAcceptor(ap, loopPid)
}

fun main() {
  var clientAP = new();
  var loopPid = spawn { serverLoop([], [], [], [], []) };
  var _ = spawn { clientAcceptor(clientAP, loopPid) };
  addRoute("/", fun (_, _) { ChatClient.mainPage(clientAP) } );
  addStaticRoute("/css", "css", [("css", "text/css")]);
  serveWebsockets();
  servePages()
}

main()
